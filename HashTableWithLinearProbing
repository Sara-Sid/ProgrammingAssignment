public class HashTableWithLinearProbing implements OurHashMap<Integer, Student> {

    private Student[] hashTable;
    private int tableSize;
    private int totalEntries;
    private int totalCollisions;

    private static final Student TOMBSTONE = new Student(-1, "TOMBSTONE", 0.0); // Using -1 for SID, assuming it won't be a real ID.

    public HashTableWithLinearProbing() {
        this(10);
    }

    public HashTableWithLinearProbing(int size) {
        this.tableSize = size;
        this.hashTable = new Student[tableSize];
        this.totalEntries = 0;
        this.totalCollisions = 0;
    }

    @Override
    public Integer getHashCode(Student s) {
        // Assuming HashCodeGenerator exists
        return HashCodeGenerator.generateHashCode(s.getSID());
    }

    @Override
    public int hashFunction(Integer key) {
        return Math.abs(key) % tableSize;
    }

    @Override
    public boolean insert(Integer key, Student data) {
        if (totalEntries == tableSize) {
            return false; // table full
        }
        int index = hashFunction(key);
        int originalIndex = index;
        boolean collisionOccurred = false;

        // Find an empty or tombstone slot
        while (hashTable[index] != null && hashTable[index] != TOMBSTONE) {
            if (getHashCode(hashTable[index]).equals(key)) {
                return false; // duplicate key
            }
            collisionOccurred = true;
            index = (index + 1) % tableSize;
            if (index == originalIndex) {
                return false; // full loop, no space
            }
        }
        
        if (collisionOccurred) {
            totalCollisions++;
        }
        
        hashTable[index] = data;
        totalEntries++;
        return true;
    }

    @Override
    public Student lookup(Integer key) {
        int index = hashFunction(key);
        int originalIndex = index;

        // Loop until a null slot is found (end of probe chain)
        while (hashTable[index] != null) {
            // Check if current element is not a tombstone and has the correct key
            if (hashTable[index] != TOMBSTONE && getHashCode(hashTable[index]).equals(key)) {
                return hashTable[index];
            }
            index = (index + 1) % tableSize;
            if (index == originalIndex) break;
        }
        return null; // not found
    }

    @Override
    public boolean delete(Integer key) {
        int index = hashFunction(key);
        int originalIndex = index;

        // Find the entry to delete
        while (hashTable[index] != null) {
            if (hashTable[index] != TOMBSTONE && getHashCode(hashTable[index]).equals(key)) {
                hashTable[index] = TOMBSTONE; // Mark the slot with a tombstone
                totalEntries--;
                return true;
            }
            index = (index + 1) % tableSize;
            if (index == originalIndex) break;
        }
        return false; // not found
    }

    @Override
    public void printHashMap() {
        System.out.println("*** Printing HashTable with Linear Probing ***");
        for (int i = 0; i < tableSize; i++) {
            if (hashTable[i] == null) {
                System.out.println(i + " >> ---");
            } else if (hashTable[i] == TOMBSTONE) {
                System.out.println(i + " >> TOMBSTONE");
            } else {
                Student s = hashTable[i];
                System.out.println(i + " >> " + s.getName() + " | ID: " + s.getSID() + " | GPA: " + s.getgpa());
            }
        }
        System.out.println("Total entries: " + totalEntries);
        System.out.println("Total collisions so far: " + totalCollisions);
    }

    public int countCollision() {
        return totalCollisions;
    }
}
